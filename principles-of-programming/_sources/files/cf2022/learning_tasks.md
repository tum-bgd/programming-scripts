# Learning Tasks

## Category 1: General Advice Qualification Goals
*These are learning tasks that are not relevant for the practical aspects of the examination. Simple
and general questions of the category knowledge (e.g., "what is cd good for") can still be part. So you are
expected to know the contents, but not to be able to apply and use them.*

- Use the command line


## Category 2: Routines
*These are learning tasks that are heavily mandatory for your future work with computers. You are not only expected
to solve the tasks, but to build routine abilities to solve them **without mental load**. The typical way of
learning is by repetition of even the same tasks with reducing support (e.g., first time you shall somehow get it done with Google, Stackoverflow, and help from others. But ultimately, you shall just sit down with not more than the plain task
description and solve it with very few mistakes.*

By now, you should already have built some routine ability to
- set up C / C++ projects either in Visual Studio or on the command line
- output strings with printf, maybe even integrating local variables or function values you computed. 
- implement loops that do what you intended
- understand the principle of recursion (building up at the moment)
- solve yourself the majority of the tasks given to you


## Category 3: In-Depth Knowledge 
*These are pieces of knowledge that you need to learn in a classical way. They come up in the examination
and are important for understanding future aspects of the lecture and the general landscape of the computational
method. Treat this knowledge as a mixture of theoretic knowledge (excerpts, definitions, learn by heart) and
application-oriented knowledge (e.g., give complexity, give reasons to certain things, proof simple complexity statements).

You should by now work on learning to
- estimate complexity of simple functions consisting of loops and function calls, but not for recursion.

## Category 4: Computer Science Excellence (out of scope!) 
*When I was asking the crowd for what the lecture is trying to teach, the first student statement has been the following,
which I extended with the condition that makes clear that this is the definition of computer science in itself. And that it is not expected to happen during this lecture. At least not routinely...*

If you want to become a famous computer scientist, find an interesting problem and
- take a mathematical formulation and make it efficient as an algorithm
